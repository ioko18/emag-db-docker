# .github/workflows/quick-check.yml
name: Quick Check

on:
  push:
    branches: ["**"]
  pull_request:

concurrency:
  group: quick-check-${{ github.ref }}
  cancel-in-progress: true

jobs:
  qc:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Asigură că .env există pentru docker compose (env_file: .env)
      - name: Ensure .env for Compose
        shell: bash
        run: |
          set -euo pipefail
          if [[ -f .env.ci ]]; then
            echo "[CI] Using .env.ci -> .env"
            cp .env.ci .env
          elif [[ -f .env.example ]]; then
            echo "[CI] Using .env.example -> .env"
            cp .env.example .env
          else
            echo "[CI] Creating minimal .env"
            {
              echo "# --- minimal CI defaults ---"
              echo "APP_PORT=8010"
              echo "DB_PORT=5434"
              echo "POSTGRES_DB=appdb"
              echo "POSTGRES_USER=appuser"
              echo "POSTGRES_PASSWORD=appsecret"
              echo "DB_SCHEMA=app"
            } > .env
          fi
          echo "[CI] .env ready:"
          sed -E 's/(POSTGRES_PASSWORD=).*/\1*** (redacted)/' .env || true

      # Buildx + cache (înlocuiește compose build)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build app image (runtime) with cache
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          target: runtime
          tags: emagdb-app:latest
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            APP_UID=10001
            APP_GID=10001

      # Pornește serviciile fără rebuild (folosește imaginea deja construită)
      - name: Start compose (no build)
        shell: bash
        run: |
          set -euo pipefail
          docker compose up -d --no-build --force-recreate
          docker compose ps

      # STRICT doar pe main; exportăm PGPASSWORD + restul PG* din .env ca psql să nu ceară parola
      - name: Quick check (STRICT on main)
        if: github.ref == 'refs/heads/main'
        shell: bash
        run: |
          set -euo pipefail
          # exportă toate variabilele din .env (sigur pentru valorile noastre simple KEY=VALUE)
          set -a; source .env; set +a
          # hint-uri pentru psql, dacă scripturile folosesc conexiune pe host
          export PGPASSWORD="${POSTGRES_PASSWORD:-}"
          export PGHOST="${PGHOST:-127.0.0.1}"
          export PGPORT="${PGPORT:-${DB_PORT:-5434}}"
          export PGUSER="${PGUSER:-${POSTGRES_USER:-appuser}}"
          export PGDATABASE="${PGDATABASE:-${POSTGRES_DB:-appdb}}"
          export SMOKE_STRICT=1
          make ci

      - name: Quick check
        if: github.ref != 'refs/heads/main'
        shell: bash
        run: |
          set -euo pipefail
          set -a; source .env; set +a
          export PGPASSWORD="${POSTGRES_PASSWORD:-}"
          export PGHOST="${PGHOST:-127.0.0.1}"
          export PGPORT="${PGPORT:-${DB_PORT:-5434}}"
          export PGUSER="${PGUSER:-${POSTGRES_USER:-appuser}}"
          export PGDATABASE="${PGDATABASE:-${POSTGRES_DB:-appdb}}"
          make ci

      - name: Dump logs on failure
        if: failure()
        shell: bash
        run: |
          docker compose ps || true
          docker compose logs --no-color > compose.log || true
          echo "---- last 200 lines of logs ----"
          tail -n 200 compose.log || true

      - name: Upload logs artifact
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: compose-logs
          path: compose.log

      - name: Teardown
        if: always()
        shell: bash
        run: |
          [[ -f .env ]] || : > .env   # dacă a eșuat devreme și .env nu există
          docker compose down -v --remove-orphans || true
